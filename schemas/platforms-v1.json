{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "https://openpackage.dev/schemas/platforms-v1.json",
  "title": "OpenPackage Platforms Configuration",
  "description": "Platform definitions for OpenPackage CLI, supporting both flow-based and legacy subdirs configurations",
  "type": "object",
  "additionalProperties": {
    "$ref": "#/definitions/platformConfig"
  },
  "definitions": {
    "platformConfig": {
      "type": "object",
      "description": "Configuration for a single platform",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Display name of the platform"
        },
        "detection": {
          "type": "array",
          "description": "Array of glob patterns for platform detection (e.g., ['.claude', 'CLAUDE.md'])",
          "items": {
            "type": "string"
          }
        },
        "aliases": {
          "type": "array",
          "description": "Alternative names for the platform",
          "items": {
            "type": "string"
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "Whether the platform is enabled (default: true)",
          "default": true
        },
        "export": {
          "type": "array",
          "description": "Export flows: Package → Workspace (install, apply)",
          "items": {
            "$ref": "#/definitions/flow"
          }
        },
        "import": {
          "type": "array",
          "description": "Import flows: Workspace → Package (save)",
          "items": {
            "$ref": "#/definitions/flow"
          }
        },
        "subdirs": {
          "type": "array",
          "description": "Legacy subdirectory mappings (deprecated, use flows instead)",
          "items": {
            "$ref": "#/definitions/subdirConfig"
          }
        },
        "description": {
          "type": "string",
          "description": "Platform description for documentation"
        },
        "variables": {
          "type": "object",
          "description": "Custom variables for flow template substitution",
          "additionalProperties": true
        }
      }
    },
    "flowPatternWithSchema": {
      "type": "object",
      "description": "Flow pattern with optional schema reference for format detection",
      "required": ["pattern"],
      "properties": {
        "pattern": {
          "type": "string",
          "description": "File pattern (supports glob patterns and {name} placeholders)"
        },
        "schema": {
          "type": "string",
          "description": "Explicit path to JSON Schema file for format detection (relative to platforms.jsonc). Example: './schemas/formats/claude-agent.schema.json'"
        }
      }
    },
    "flow": {
      "type": "object",
      "description": "Defines a transformation from source to target",
      "required": ["from", "to"],
      "properties": {
        "from": {
          "oneOf": [
            {
              "type": "string",
              "description": "Source file pattern (supports glob patterns and {name} placeholders)"
            },
            {
              "$ref": "#/definitions/flowPatternWithSchema",
              "description": "Pattern with optional schema reference for format detection"
            },
            {
              "type": "array",
              "description": "Array of source patterns with priority (first match wins)",
              "items": {
                "oneOf": [
                  { "type": "string" },
                  { "$ref": "#/definitions/flowPatternWithSchema" }
                ]
              },
              "minItems": 1
            },
            {
              "$ref": "#/definitions/switchExpression",
              "description": "Switch expression for conditional source path resolution"
            }
          ]
        },
        "to": {
          "oneOf": [
            {
              "type": "string",
              "description": "Single target path"
            },
            {
              "$ref": "#/definitions/flowPatternWithSchema",
              "description": "Pattern with optional schema reference for format detection"
            },
            {
              "type": "object",
              "description": "Multi-target configuration",
              "additionalProperties": {
                "$ref": "#/definitions/multiTargetFlowConfig"
              }
            },
            {
              "$ref": "#/definitions/switchExpression",
              "description": "Switch expression for conditional target path resolution"
            }
          ]
        },
        "map": {
          "type": "array",
          "description": "Map Pipeline - array of transformation operations (includes $pipe for transform registry operations)",
          "minItems": 1,
          "items": {
            "type": "object",
            "description": "A single map operation ($set, $rename, $unset, $switch, $pipeline, $copy, $pipe)"
          }
        },
        "pick": {
          "type": "array",
          "description": "Keys to include (whitelist)",
          "items": {
            "type": "string"
          }
        },
        "omit": {
          "type": "array",
          "description": "Keys to exclude (blacklist)",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "type": "string",
          "description": "JSONPath expression to extract subset of data"
        },
        "embed": {
          "type": "string",
          "description": "Embed content under this key in the target"
        },
        "section": {
          "type": "string",
          "description": "TOML section name (for TOML targets)"
        },
        "when": {
          "$ref": "#/definitions/condition",
          "description": "Conditional execution"
        },
        "merge": {
          "type": "string",
          "enum": ["deep", "shallow", "replace", "composite"],
          "description": "Merge strategy when target exists (default: 'replace')",
          "default": "replace"
        },
        "handler": {
          "type": "string",
          "description": "Custom handler name for edge cases"
        },
        "priority": {
          "type": "number",
          "description": "Priority for conflict resolution (higher = wins, default: 0)",
          "default": 0
        },
        "description": {
          "type": "string",
          "description": "Flow description for documentation/debugging"
        }
      }
    },
    "multiTargetFlowConfig": {
      "type": "object",
      "description": "Configuration for a single target in a multi-target flow",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether this target is enabled (default: true)",
          "default": true
        },
        "map": {
          "type": "array",
          "description": "Map Pipeline overrides (includes $pipe for transform registry operations)",
          "minItems": 1,
          "items": {
            "type": "object"
          }
        },
        "pick": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "omit": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "path": {
          "type": "string"
        },
        "embed": {
          "type": "string"
        },
        "section": {
          "type": "string"
        },
        "merge": {
          "type": "string",
          "enum": ["deep", "shallow", "replace", "composite"]
        },
        "description": {
          "type": "string"
        }
      }
    },

    "switchExpression": {
      "type": "object",
      "description": "Switch expression for conditional target path resolution (MongoDB $switch inspired)",
      "required": ["$switch"],
      "properties": {
        "$switch": {
          "type": "object",
          "required": ["field", "cases"],
          "properties": {
            "field": {
              "type": "string",
              "description": "Context variable to evaluate (e.g., '$$targetRoot')"
            },
            "cases": {
              "type": "array",
              "description": "Pattern cases to match (evaluated in order, first match wins)",
              "minItems": 1,
              "items": {
                "$ref": "#/definitions/switchCase"
              }
            },
            "default": {
              "oneOf": [
                {
                  "type": "string",
                  "description": "Default target path if no pattern matches"
                },
                {
                  "$ref": "#/definitions/flowPatternWithSchema",
                  "description": "Default target path with schema for format detection"
                }
              ],
              "description": "Optional default value if no pattern matches"
            }
          }
        }
      }
    },
    "switchCase": {
      "type": "object",
      "description": "Switch case for pattern matching",
      "required": ["pattern", "value"],
      "properties": {
        "pattern": {
          "oneOf": [
            {
              "type": "string",
              "description": "String pattern for equality/glob matching"
            },
            {
              "type": "object",
              "description": "Object pattern for shape matching"
            }
          ]
        },
        "value": {
          "oneOf": [
            {
              "type": "string",
              "description": "Target path to use if pattern matches"
            },
            {
              "$ref": "#/definitions/flowPatternWithSchema",
              "description": "Target path with schema for format detection"
            }
          ]
        }
      }
    },
    "condition": {
      "type": "object",
      "description": "Conditions for flow execution",
      "properties": {
        "exists": {
          "type": "string",
          "description": "File or directory must exist"
        },
        "platform": {
          "type": "string",
          "description": "Platform must be enabled"
        },
        "key": {
          "type": "string",
          "description": "Key must exist in source data"
        },
        "equals": {
          "description": "Key must equal specific value"
        },
        "$eq": {
          "type": "array",
          "description": "Equality check: [left, right] where left and right can be $$variables or literal values",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "type": "string"
          }
        },
        "$ne": {
          "type": "array",
          "description": "Not equal check: [left, right] where left and right can be $$variables or literal values",
          "minItems": 2,
          "maxItems": 2,
          "items": {
            "type": "string"
          }
        },
        "and": {
          "type": "array",
          "description": "All conditions must be true",
          "items": {
            "$ref": "#/definitions/condition"
          }
        },
        "or": {
          "type": "array",
          "description": "Any condition must be true",
          "items": {
            "$ref": "#/definitions/condition"
          }
        },
        "not": {
          "$ref": "#/definitions/condition",
          "description": "Condition must be false"
        }
      }
    },
    "subdirConfig": {
      "type": "object",
      "description": "Legacy subdirectory mapping (deprecated)",
      "required": ["universalDir", "platformDir"],
      "properties": {
        "universalDir": {
          "type": "string",
          "description": "Universal directory name (e.g., 'rules', 'commands')"
        },
        "platformDir": {
          "type": "string",
          "description": "Platform-specific directory name"
        },
        "exts": {
          "type": "array",
          "description": "Allowed file extensions (undefined = all, [] = none)",
          "items": {
            "type": "string",
            "pattern": "^\\."
          }
        },
        "transformations": {
          "type": "array",
          "description": "Extension transformations",
          "items": {
            "$ref": "#/definitions/extensionTransformation"
          }
        }
      }
    },
    "extensionTransformation": {
      "type": "object",
      "description": "Extension transformation between package and workspace",
      "required": ["packageExt", "workspaceExt"],
      "properties": {
        "packageExt": {
          "type": "string",
          "description": "Package (registry) extension",
          "pattern": "^\\."
        },
        "workspaceExt": {
          "type": "string",
          "description": "Workspace extension",
          "pattern": "^\\."
        }
      }
    },
    "globalConfig": {
      "type": "object",
      "description": "Global flows configuration",
      "properties": {
        "export": {
          "type": "array",
          "description": "Global export flows (package → workspace) applied before platform-specific flows",
          "items": {
            "$ref": "#/definitions/flow"
          }
        },
        "import": {
          "type": "array",
          "description": "Global import flows (workspace → package) applied before platform-specific flows",
          "items": {
            "$ref": "#/definitions/flow"
          }
        },
        "description": {
          "type": "string",
          "description": "Configuration description"
        }
      }
    }
  },
  "examples": [
    {
      "cursor": {
        "name": "Cursor",
        "rootDir": ".cursor",
        "rootFile": "AGENTS.md",
        "export": [
          {
            "from": "rules/{name}.md",
            "to": ".cursor/rules/{name}.mdc",
            "description": "Transform rules to .mdc format"
          },
          {
            "from": "commands/{name}.md",
            "to": ".cursor/commands/{name}.md"
          },
          {
            "from": ["mcp.jsonc", "mcp.json"],
            "to": ".cursor/mcp.json",
            "pipe": ["filter-comments"],
            "merge": "deep"
          }
        ],
        "import": [
          {
            "from": [".cursor/rules/{name}.mdc", ".cursor/rules/{name}.md"],
            "to": "rules/{name}.md"
          },
          {
            "from": ".cursor/commands/{name}.md",
            "to": "commands/{name}.md"
          },
          {
            "from": [".cursor/mcp.json", ".cursor/mcp.jsonc"],
            "to": "mcp.jsonc"
          }
        ]
      },
      "claude": {
        "name": "Claude Code",
        "rootDir": ".claude",
        "rootFile": "CLAUDE.md",
        "aliases": ["claudecode"],
        "export": [
          {
            "from": "rules/{name}.md",
            "to": ".claude/rules/{name}.md"
          },
          {
            "from": "agents/{name}.md",
            "to": ".claude/agents/{name}.md",
            "map": [
              { "$set": { "name": "$$filename" } }
            ]
          }
        ],
        "import": [
          {
            "from": ".claude/rules/{name}.md",
            "to": "rules/{name}.md"
          },
          {
            "from": ".claude/agents/{name}.md",
            "to": "agents/{name}.md",
            "map": [
              { "$unset": "name" }
            ]
          }
        ]
      }
    }
  ]
}
