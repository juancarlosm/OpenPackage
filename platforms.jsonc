{
  "$schema": "./schemas/platforms-v1.json",

  // Global flows that apply to all platforms
  "global": {
    "export": [
      {
        "from": "AGENTS.md",
        "to": "AGENTS.md",
        "when": { "exists": "AGENTS.md" },
        "merge": "composite"
      }
    ],
    "import": [
      {
        "from": "AGENTS.md",
        "to": "AGENTS.md",
        "merge": "composite"
      }
    ]
  },

  // Platform definitions for all supported AI coding platforms
  // Each platform defines export flows (package → workspace) and import flows (workspace → package)

  "adal": {
    "name": "AdaL",
    "detection": [".adal"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".adal/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".adal/settings.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".adal/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".adal/settings.json",
        "to": "mcp.jsonc"
      }
    ]
  },

  // Amp
  "amp": {
    "name": "Amp",
    "detection": [".agents", "AGENTS.md"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".agents/skills/**/*"
      },
      {
        "from": "rules/**/*.md",
        "to": ".agents/checks/**/*.md",
        "comment": "Amp uses 'checks' terminology for rules"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/amp/settings.json" }
            ],
            "default": ".amp/settings.json"
          }
        },
        "map": [
          {
            "$comment": "Nest under amp.mcpServers key",
            "$rename": { "mcpServers": "amp.mcpServers" }
          }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".agents/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".agents/checks/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/amp/settings.json" }
            ],
            "default": ".amp/settings.json"
          }
        },
        "to": "mcp.jsonc",
        "map": [
          {
            "$comment": "Extract from amp.mcpServers key",
            "$rename": { "amp.mcpServers": "mcpServers" }
          }
        ]
      }
    ]
  },

  "antigravity": {
    "name": "Google Antigravity",
    "detection": [".agent"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".agent/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".agent/workflows/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".agent/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".agent/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".agent/workflows/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".agent/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "augment": {
    "name": "Augment Code",
    "detection": [".augment"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".augment/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".augment/commands/**/*.md"
      }
    ],
    "import": [
      {
        "from": ".augment/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".augment/commands/**/*.md",
        "to": "commands/**/*.md"
      }
    ]
  },

  "claude-plugin": {
    "name": "Claude Code Plugin",
    "detection": [".claude-plugin/plugin.json"],
    "export": [
      {
        "from": "openpackage.yml",
        "to": ".claude-plugin/plugin.json"
      },
      {
        "from": "rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": "mcp.jsonc",
        "to": ".mcp.json",
        "map": [
          // Claude plugin `.mcp.json` expects a bare server map:
          //   { "linear": { ... } }
          // Universal format is:
          //   { "mcpServers": { "linear": { ... } } }
          // Only transform keys under `mcpServers` (no-op if missing).
          { "$rename": { "mcpServers.*": "*" } },
          { "$unset": "mcpServers" }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".claude-plugin/plugin.json",
        "to": "openpackage.yml"
      },
      {
        "from": "rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": "agents/**/*.md",
        // No mapping when target platform is Claude (already in Claude format)
        "when": {
          "$eq": ["$$platform", "claude"]
        }
      },
      {
        "from": "agents/**/*.md",
        "to": "agents/**/*.md",
        // Apply reverse transformations when target platform is NOT Claude
        "when": {
          "$ne": ["$$platform", "claude"]
        },
        "map": [
          // Reverse model transformation
          {
            "$pipeline": {
              "field": "model",
              "operations": [
                // Step 1: Convert version hyphens back to dots
                // claude-sonnet-4-20250514 → claude-sonnet-4.20250514
                { "$replace": { "pattern": "(-[0-9]+)-([0-9]+)", "with": "$1.$2", "flags": "g" } },
                
                // Step 2: Add anthropic/ prefix ONLY if:
                //   - It starts with "claude-" (Claude model without prefix)
                //   - NOT if it's "default"
                //   - NOT if it already has "anthropic/"
                { "$replace": { "pattern": "^(claude-.+)$", "with": "anthropic/$1" } }
              ]
            }
          },
          
          // Reverse tools transformation: "Bash, Read" → [bash, read]
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Step 1: Split "Read, Write, Bash" → ["Read", "Write", "Bash"]
                { "$reduce": { "type": "split", "separator": ", " } },
                // Step 2: Lowercase all (Read→read, Bash→bash, AskUserQuestion→askuserquestion)
                { "$map": { "each": "lowercase" } },
                // Step 3: Replace special cases AFTER lowercase
                { "$map": {
                    "replace": {
                      "askuserquestion": "question",
                      "notebookedit": "notebook",
                      "exitplanmode": "exitplan"
                    }
                }}
              ]
            }
          }
        ]
      },
      {
        "from": "skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".mcp.json",
        "to": "mcp.jsonc",
        "map": [
          // Claude plugin `.mcp.json` may be a bare server map:
          //   { "linear": { ... } }
          // Convert to universal format:
          //   { "mcpServers": { "linear": { ... } } }
          { "$rename": { "*": "mcpServers.*" } }
        ]
      }
    ]
  },

  "claude": {
    "name": "Claude Code",
    "detection": [".claude", "CLAUDE.md"],
    "aliases": ["claudecode"],
    "export": [
      {
        "from": "AGENTS.md",
        "to": "CLAUDE.md",
        "merge": "composite"
      },
      {
        "from": "rules/**/*.md",
        "to": ".claude/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".claude/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".claude/agents/**/*.md",
        // No mapping when source is Claude plugin (already in Claude format)
        "when": {
          "$eq": ["$$source", "claude-plugin"]
        }
      },
      {
        "from": { 
          "pattern": "agents/**/*.md",
          "schema": "./schemas/formats/universal-agent.schema.json"
        },
        "to": { 
          "pattern": ".claude/agents/**/*.md",
          "schema": "./schemas/formats/claude-agent.schema.json"
        },
        // Apply transformations when source is NOT Claude plugin
        "when": {
          "$ne": ["$$source", "claude-plugin"]
        },
        "map": [
          // 1. Inject filename as name (Claude requirement)
          { "$set": { "name": "$$filename" } },
          
          // 2. Transform model: "provider/model-id" → Claude short names
          {
            "$pipeline": {
              "field": "model",
              "operations": [
                // Step 1: For non-Anthropic providers (openai/, google/, etc.), set to "inherit"
                // But preserve Claude shorthand names (opus, sonnet, haiku) and full claude- model IDs
                { "$replace": { "pattern": "^(?!anthropic/|claude-|opus$|sonnet$|haiku$).*/.+$", "with": "inherit" } },
                // Step 2: Remove anthropic/ prefix
                { "$replace": { "pattern": "^anthropic/", "with": "" } },
                // Step 3: Convert version dots to hyphens: claude-sonnet-4.20250514 → claude-sonnet-4-20250514
                { "$replace": { "pattern": "(-[0-9]+)\\.([0-9]+)", "with": "$1-$2", "flags": "g" } }
              ]
            }
          },
          
          // 3. Transform tools: [read, write, bash] → "Read, Write, Bash"
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Step 1: Replace special cases BEFORE capitalization
                { "$map": { 
                    "replace": {
                      "question": "AskUserQuestion",
                      "notebook": "NotebookEdit", 
                      "exitplan": "ExitPlanMode"
                    }
                }},
                // Step 2: Capitalize everything (handles read→Read, bash→Bash, etc.)
                { "$map": { "each": "capitalize" } },
                // Step 3: Join with comma-space
                { "$reduce": { "type": "join", "separator": ", " } }
              ]
            }
          },
          
          // 4. Smart map permissions object → permissionMode string
          // Only transform if permissions field exists
          {
            "$switch": {
              "field": "permissions",
              "cases": [
                // Full automation: all allow
                { 
                  "pattern": { "edit": "allow", "bash": "allow", "webfetch": "allow" }, 
                  "value": "bypassPermissions" 
                },
                { 
                  "pattern": { "edit": "allow", "bash": "allow" }, 
                  "value": "bypassPermissions" 
                },
                
                // Auto-accept edits
                { 
                  "pattern": { "edit": "allow", "bash": "ask" }, 
                  "value": "acceptEdits" 
                },
                { 
                  "pattern": { "edit": "allow" }, 
                  "value": "acceptEdits" 
                },
                
                // Read-only mode
                { 
                  "pattern": { "edit": "deny", "bash": "deny" }, 
                  "value": "plan" 
                },
                
                // Deny unclear operations
                { 
                  "pattern": { "edit": "deny", "bash": "ask" }, 
                  "value": "dontAsk" 
                },
                { 
                  "pattern": { "edit": "deny", "bash": "allow" }, 
                  "value": "dontAsk" 
                },
                
                // Standard prompting
                { 
                  "pattern": { "edit": "ask", "bash": "ask" }, 
                  "value": "default" 
                },
                { 
                  "pattern": { "edit": "ask" }, 
                  "value": "default" 
                }
              ]
            }
          },
          { "$rename": { "permissions": "permissionMode" } }
        ]
      },
      {
        "from": "skills/**/*",
        "to": ".claude/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".mcp.json",
        "when": {
          "$ne": ["$$targetRoot", "~/"]
        },
        "merge": "deep"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".claude.json",
        "when": {
          "$eq": ["$$targetRoot", "~/"]
        },
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": "CLAUDE.md",
        "to": "AGENTS.md",
        "merge": "composite"
      },
      {
        "from": ".claude/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".claude/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": { 
          "pattern": ".claude/agents/**/*.md",
          "schema": "./schemas/formats/claude-agent.schema.json"
        },
        "to": { 
          "pattern": "agents/**/*.md",
          "schema": "./schemas/formats/universal-agent.schema.json"
        },
        "map": [
          // Reverse model transformation: Claude short names → "anthropic/model-id"
          {
            "$pipeline": {
              "field": "model",
              "operations": [
                // Convert version hyphens back to dots: claude-sonnet-4-20250514 → claude-sonnet-4.20250514
                { "$replace": { "pattern": "(-[0-9]+)-([0-9]+)", "with": "$1.$2", "flags": "g" } },
                
                // Add anthropic/ prefix if it's a Claude model (starts with "claude-")
                // Skip if it's "inherit" or already has "anthropic/"
                { "$replace": { "pattern": "^(claude-.+)$", "with": "anthropic/$1" } }
              ]
            }
          },
          
          // Reverse tools transformation: "Read, Write, Bash" → [read, write, bash]
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Step 1: Split "Read, Write, Bash" → ["Read", "Write", "Bash"]
                { "$reduce": { "type": "split", "separator": ", " } },
                // Step 2: Lowercase all (Read→read, Bash→bash, AskUserQuestion→askuserquestion)
                { "$map": { "each": "lowercase" } },
                // Step 3: Replace special cases AFTER lowercase
                { "$map": {
                    "replace": {
                      "askuserquestion": "question",
                      "notebookedit": "notebook",
                      "exitplanmode": "exitplan"
                    }
                }}
              ]
            }
          },
          
          // Transform permissionMode → permissions object (best effort)
          // Only transform if permissionMode field exists
          {
            "$switch": {
              "field": "permissionMode",
              "cases": [
                { "pattern": "bypassPermissions", "value": { "edit": "allow", "bash": "allow" } },
                { "pattern": "acceptEdits", "value": { "edit": "allow", "bash": "ask" } },
                { "pattern": "plan", "value": { "edit": "deny", "bash": "deny" } },
                { "pattern": "dontAsk", "value": { "edit": "deny", "bash": "ask" } },
                { "pattern": "default", "value": { "edit": "ask", "bash": "ask" } }
              ]
            }
          },
          { "$rename": { "permissionMode": "permissions" } }
        ]
      },
      {
        "from": ".claude/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".mcp.json",
        "to": "mcp.jsonc",
        "when": {
          "$ne": ["$$targetRoot", "~/"]
        }
      },
      {
        "from": ".claude.json",
        "to": "mcp.jsonc",
        "when": {
          "$eq": ["$$targetRoot", "~/"]
        }
      }
    ]
  },

  "cline": {
    "name": "Cline",
    "detection": [".cline"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".cline/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": "cline_mcp_settings.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".cline/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": "cline_mcp_settings.json",
        "to": "mcp.jsonc"
      }
    ]
  },

  // CodeBuddy
  "codebuddy": {
    "name": "CodeBuddy",
    "detection": [".codebuddy", "CODEBUDDY.md"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".codebuddy/skills/**/*"
      },
      {
        "from": "rules/**/*.md",
        "to": ".codebuddy/rules/**/*.mdc",
        "comment": "CodeBuddy uses .mdc extension for rules"
      }
    ],
    // MCP: Settings UI-based, file path unclear - needs verification before adding
    "import": [
      {
        "from": ".codebuddy/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".codebuddy/rules/**/*.mdc",
        "to": "rules/**/*.md"
      }
    ]
  },

  "codex": {
    "name": "Codex CLI",
    "detection": [".codex", "AGENTS.md"],
    "aliases": ["codexcli"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".codex/prompts/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".codex/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".codex/config.toml",
        "map": [
          // 1. Rename root key
          { "$rename": { "mcpServers": "mcp_servers" } },

          // 2. Extract bearer token from Authorization header
          {
            "$pipeline": {
              "field": "mcp_servers.*.headers.Authorization",
              "operations": [
                { "$extract": {
                    "pattern": "^Bearer \\$\\{env:([A-Z_][A-Z0-9_]*)\\}$",
                    "group": 1,
                    "default": "$SELF"
                }}
              ]
            }
          },
          { "$rename": { "mcp_servers.*.headers.Authorization": "mcp_servers.*.bearer_token_env_var" } },

          // 3. Partition headers into env and static
          {
            "$pipeline": {
              "field": "mcp_servers.*.headers",
              "operations": [
                { "$partition": {
                    "by": "value",
                    "patterns": {
                      "env_http_headers": "^\\$\\{env:.*\\}$",
                      "http_headers": ".*"
                    }
                }}
              ]
            }
          },

          // 4. Extract env var names from env_http_headers
          {
            "$pipeline": {
              "field": "mcp_servers.*.headers.env_http_headers",
              "operations": [
                { "$mapValues": {
                    "operations": [
                      { "$extract": {
                          "pattern": "^\\$\\{env:([A-Z_][A-Z0-9_]*)\\}$",
                          "group": 1
                      }}
                    ]
                }}
              ]
            }
          },

          // 5. Flatten to server level
          { "$rename": { "mcp_servers.*.headers.http_headers": "mcp_servers.*.http_headers" } },
          { "$rename": { "mcp_servers.*.headers.env_http_headers": "mcp_servers.*.env_http_headers" } },
          { "$unset": "mcp_servers.*.headers" },

          // 6. Rename timeout
          { "$rename": { "mcp_servers.*.timeout": "mcp_servers.*.startup_timeout_sec" } },

          // Post-process: Convert to TOML
          { "$pipe": ["json-to-toml"] }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".codex/prompts/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".codex/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".codex/config.toml",
        "to": "mcp.jsonc",
        "map": [
          // Pre-process: Parse TOML
          { "$pipe": ["toml-to-json"] },

          // 1. Wrap env vars
          {
            "$pipeline": {
              "field": "mcp_servers.*.env_http_headers",
              "operations": [
                { "$mapValues": {
                    "operations": [
                      { "$replace": { "pattern": "^(.+)$", "with": "${env:$1}" } }
                    ]
                }}
              ]
            }
          },

          // 2. Merge headers
          {
            "$pipeline": {
              "field": "mcp_servers.*",
              "operations": [
                { "$mergeFields": {
                    "from": ["http_headers", "env_http_headers"],
                    "to": "headers"
                }}
              ]
            }
          },

          // 3. Reconstruct Authorization header
          {
            "$pipeline": {
              "field": "mcp_servers.*.bearer_token_env_var",
              "operations": [
                { "$replace": { "pattern": "^(.+)$", "with": "Bearer ${env:$1}" } }
              ]
            }
          },
          { "$rename": { "mcp_servers.*.bearer_token_env_var": "mcp_servers.*.headers.Authorization" } },

          // 4. Rename timeout
          { "$rename": { "mcp_servers.*.startup_timeout_sec": "mcp_servers.*.timeout" } },

          // 5. Rename top-level key
          { "$rename": { "mcp_servers": "mcpServers" } }
        ]
      }
    ]
  },

  // Command Code
  // Note: No MCP support in this platform
  "commandcode": {
    "name": "Command Code",
    "detection": [".commandcode"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".commandcode/skills/**/*"
      },
      {
        "from": "commands/**/*.md",
        "to": ".commandcode/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".commandcode/agents/**/*.md"
      }
    ],
    "import": [
      {
        "from": ".commandcode/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".commandcode/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".commandcode/agents/**/*.md",
        "to": "agents/**/*.md"
      }
    ]
  },

  // Continue
  "continue": {
    "name": "Continue",
    "detection": [".continue"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".continue/skills/**/*"
      },
      {
        "from": "rules/**/*.md",
        "to": ".continue/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".continue/prompts/**/*.md",
        "comment": "Continue uses 'prompts' terminology"
      },
      {
        "from": "agents/**/*.md",
        "to": ".continue/agents/**/*.md"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".continue/mcpServers/*.yaml",
        "comment": "Continue prefers YAML format",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".continue/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".continue/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".continue/prompts/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".continue/agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": [".continue/mcpServers/*.yaml", ".continue/mcpServers/*.json"],
        "to": "mcp.jsonc"
      }
    ]
  },

  // Crush
  "crush": {
    "name": "Crush",
    "detection": [".crush", "crush.json"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".config/crush/skills/**/*",
        "comment": "Crush uses configurable skills_paths array"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": "crush.json",
        "map": [
          {
            "$comment": "Embed under 'mcp' key",
            "$rename": { "mcpServers": "mcp" }
          }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".config/crush/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": "crush.json",
        "to": "mcp.jsonc",
        "map": [
          {
            "$comment": "Extract from 'mcp' key",
            "$rename": { "mcp": "mcpServers" }
          }
        ]
      }
    ]
  },

  "cursor": {
    "name": "Cursor",
    "detection": [".cursor", "AGENTS.md"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".cursor/rules/**/*.mdc"
      },
      {
        "from": "commands/**/*.md",
        "to": ".cursor/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".cursor/agents/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".cursor/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".cursor/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": [".cursor/rules/**/*.mdc", ".cursor/rules/**/*.md"],
        "to": "rules/**/*.md"
      },
      {
        "from": ".cursor/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".cursor/agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".cursor/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".cursor/mcp.json", ".cursor/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "factory": {
    "name": "Factory AI",
    "detection": [".factory", "AGENTS.md"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".factory/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".factory/droids/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".factory/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".factory/settings/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".factory/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".factory/droids/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".factory/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".factory/settings/mcp.json", ".factory/settings/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  // GitHub Copilot
  // Note: Uses .github/agents/, NOT .agents/
  "copilot": {
    "name": "GitHub Copilot",
    "detection": [".github/agents"],
    "aliases": ["githubcopilot", "github-copilot"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".github/skills/**/*"
      },
      {
        "from": "agents/**/*.md",
        "to": ".github/agents/**/*.md",
        "comment": "Custom agents with YAML frontmatter"
      }
    ],
    // MCP: Stored in repository settings UI, no file-based export
    "import": [
      {
        "from": ".github/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".github/agents/**/*.md",
        "to": "agents/**/*.md"
      }
    ]
  },

  "goose": {
    "name": "Goose",
    "detection": [".goose", ".goosehints"],
    "export": [
      {
        "from": "skills/**/*",
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/goose/skills/**/*" }
            ],
            "default": ".goose/skills/**/*"
          }
        }
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/goose/config.yaml" }
            ],
            "default": ".goose/config.yaml"
          }
        },
        "map": [
          {
            "$comment": "Goose uses 'extensions' key instead of 'mcpServers'",
            "$rename": { "mcpServers": "extensions" }
          },
          { "$pipe": ["json-to-yaml"] }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/goose/skills/**/*" }
            ],
            "default": ".goose/skills/**/*"
          }
        },
        "to": "skills/**/*"
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/goose/config.yaml" }
            ],
            "default": ".goose/config.yaml"
          }
        },
        "to": "mcp.jsonc",
        "map": [
          { "$pipe": ["yaml-to-json"] },
          {
            "$comment": "Extract from 'extensions' key",
            "$rename": { "extensions": "mcpServers" }
          }
        ]
      }
    ]
  },

  "iflow": {
    "name": "iFlow CLI",
    "detection": [".iflow"],
    "aliases": ["iflow-cli"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".iflow/skills/**/*"
      },
      {
        "from": "AGENTS.md",
        "to": "IFLOW.md",
        "merge": "composite"
      },
      {
        "from": "agents/**/*.md",
        "to": ".iflow/agents/**/*.md",
        "comment": "iFlow calls them SubAgents"
      },
      {
        "from": "commands/**/*.md",
        "to": ".iflow/commands/**/*.md",
        "comment": "iFlow calls them SubCommands"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".iflow/settings.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".iflow/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": "IFLOW.md",
        "to": "AGENTS.md",
        "merge": "composite"
      },
      {
        "from": ".iflow/agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".iflow/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".iflow/settings.json",
        "to": "mcp.jsonc"
      }
    ]
  },

  "junie": {
    "name": "Junie",
    "detection": [".junie"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".junie/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".junie/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "kilo": {
    "name": "Kilo Code",
    "detection": [".kilocode", "AGENTS.md"],
    "aliases": ["kilocode"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".kilocode/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".kilocode/workflows/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".kilocode/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".kilocode/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".kilocode/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".kilocode/workflows/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".kilocode/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".kilocode/mcp.json", ".kilocode/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  // Kimi Code CLI
  "kimi": {
    "name": "Kimi Code CLI",
    "detection": [".agents"],
    "aliases": ["kimi-cli", "kimi-code"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".agents/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".kimi/mcp.json",
        "comment": "Kimi only supports global MCP config",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".agents/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".kimi/mcp.json",
        "to": "mcp.jsonc"
      }
    ]
  },

  "kiro": {
    "name": "Kiro",
    "detection": [".kiro"],
    "aliases": ["kiro-cli"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".kiro/steering/**/*.md",
        "comment": "Kiro uses 'steering' terminology for rules"
      },
      {
        "from": "skills/**/*",
        "to": ".kiro/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".kiro/settings/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".kiro/steering/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".kiro/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".kiro/settings/mcp.json", ".kiro/settings/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "kode": {
    "name": "Kode",
    "detection": [".kode"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".kode/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".kode/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "mcpjam": {
    "name": "MCPJam",
    "detection": [".mcpjam"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".mcpjam/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".mcpjam/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "mistralvibe": {
    "name": "Mistral Vibe",
    "detection": [".vibe"],
    "aliases": ["mistral-vibe"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".vibe/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".vibe/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "mux": {
    "name": "Mux",
    "detection": [".mux"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".mux/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".mux/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "neovate": {
    "name": "Neovate",
    "detection": [".neovate"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".neovate/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".neovate/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".neovate/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".neovate/mcp.json",
        "to": "mcp.jsonc"
      }
    ]
  },

  "opencode": {
    "name": "OpenCode",
    "detection": [".opencode", "AGENTS.md"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/commands/**/*.md" }
            ],
            "default": ".opencode/commands/**/*.md"
          }
        }
      },
      {
        "from": { 
          "pattern": "agents/**/*.md",
          "schema": "./schemas/formats/universal-agent.schema.json"
        },
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { 
                "pattern": "~/", 
                "value": { 
                  "pattern": ".config/opencode/agents/**/*.md",
                  "schema": "./schemas/formats/opencode-agent.schema.json"
                }
              }
            ],
            "default": { 
              "pattern": ".opencode/agents/**/*.md",
              "schema": "./schemas/formats/opencode-agent.schema.json"
            }
          }
        },
        "map": [
          // 1. Transform tools: [read, write, bash] → { read: true, write: true, bash: true }
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                { "$arrayToObject": { "value": true } }
              ]
            }
          },
          
          // 2. Model field: pass through as-is (already in OpenCode format)
          // 3. Permissions: pass through as-is (already in OpenCode format)
          // 4. Claude-specific fields preserved (skills, hooks, disallowedTools) - ignored by OpenCode but kept for information preservation
        ]
      },
      {
        "from": "skills/**/*",
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/skills/**/*" }
            ],
            "default": ".opencode/skills/**/*"
          }
        }
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/opencode.json" }
            ],
            "default": ".opencode/opencode.json"
          }
        },
        "map": [
          { "$rename": { "mcpServers": "mcp" } }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/commands/**/*.md" }
            ],
            "default": ".opencode/commands/**/*.md"
          }
        },
        "to": "commands/**/*.md"
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/agents/**/*.md" }
            ],
            "default": ".opencode/agents/**/*.md"
          }
        },
        "to": "agents/**/*.md",
        "map": [
          // 1. Reverse tools transformation: { read: true, write: false, bash: true } → [read, bash]
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Filter to only enabled tools
                { "$filter": { "match": { "value": true } } },
                // Extract keys
                { "$objectToArray": { "extract": "keys" } }
              ]
            }
          }
          
          // 2. Model field: pass through as-is (already in universal format)
          // 3. Permissions: pass through as-is (already in universal format)
        ]
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/skills/**/*" }
            ],
            "default": ".opencode/skills/**/*"
          }
        },
        "to": "skills/**/*"
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/opencode.json" }
            ],
            "default": ".opencode/opencode.json"
          }
        },
        "to": "mcp.jsonc",
        "map": [
          { "$rename": { "mcp": "mcpServers" } }
        ]
      }
    ]
  },

  "openclaw": {
    "name": "OpenClaw",
    "detection": ["skills"],
    "export": [
      {
        "from": "skills/**/*",
        "to": "skills/**/*"
      }
    ],
    "import": [
      {
        "from": "skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "openhands": {
    "name": "OpenHands",
    "detection": [".openhands"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".openhands/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".openhands/mcp.json",
        "when": {
          "$eq": ["$$targetRoot", "~/"]
        },
        "comment": "OpenHands only supports user-level MCP config",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".openhands/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".openhands/mcp.json",
        "to": "mcp.jsonc",
        "when": {
          "$eq": ["$$targetRoot", "~/"]
        }
      }
    ]
  },

  // Pi-Mono AI coding assistant framework
  "pimono": {
    "name": "Pi-Mono",
    "detection": [".pi"],
    "aliases": ["pi-mono", "pi"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".pi/agent/prompts/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".pi/agent/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".pi/agent/prompts/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".pi/agent/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "pochi": {
    "name": "Pochi",
    "detection": [".pochi"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".pochi/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".pochi/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "qoder": {
    "name": "Qoder",
    "detection": [".qoder"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".qoder/skills/**/*"
      },
      {
        "from": "rules/**/*.md",
        "to": ".qoder/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".qoder/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".qoder/agents/**/*.md",
        "comment": "Qoder calls them SubAgents with required frontmatter: name, description, tools"
      }
    ],
    // MCP: UI-managed only (Settings > MCP), no file-based project configuration
    "import": [
      {
        "from": ".qoder/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".qoder/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".qoder/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".qoder/agents/**/*.md",
        "to": "agents/**/*.md"
      }
    ]
  },

  "qwen": {
    "name": "Qwen Code",
    "detection": [".qwen", "QWEN.md"],
    "aliases": ["qwencode"],
    "export": [
      {
        "from": "AGENTS.md",
        "to": "QWEN.md",
        "merge": "composite"
      },
      {
        "from": "agents/**/*.md",
        "to": ".qwen/agents/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".qwen/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".qwen/settings.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": "QWEN.md",
        "to": "AGENTS.md",
        "merge": "composite"
      },
      {
        "from": ".qwen/agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".qwen/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".qwen/settings.json", ".qwen/settings.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "roo": {
    "name": "Roo Code",
    "detection": [".roo", "AGENTS.md"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".roo/commands/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".roo/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".roo/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".roo/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".roo/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".roo/mcp.json", ".roo/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  // Replit
  "replit": {
    "name": "Replit",
    "detection": [".agents", ".replit"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".agents/skills/**/*"
      },
      {
        "from": "AGENTS.md",
        "to": "replit.md",
        "comment": "Replit uses replit.md for agent guidance",
        "merge": "composite"
      }
    ],
    // MCP: User account level only, no project-level config
    "import": [
      {
        "from": ".agents/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": "replit.md",
        "to": "AGENTS.md",
        "merge": "composite"
      }
    ]
  },

  "trae": {
    "name": "Trae",
    "detection": [".trae"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".trae/skills/**/*"
      },
      {
        "from": "rules/**/*.md",
        "to": ".trae/rules/**/*.md"
      }
    ],
    // MCP: Officially supported but configuration path unclear (likely UI-based)
    // Agents: Custom agent feature promoted but configuration method unclear
    "import": [
      {
        "from": ".trae/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".trae/rules/**/*.md",
        "to": "rules/**/*.md"
      }
    ]
  },

  "traecn": {
    "name": "Trae CN",
    "detection": [".trae-cn"],
    "aliases": ["trae-cn"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".trae-cn/skills/**/*"
      },
      {
        "from": "rules/**/*.md",
        "to": ".trae-cn/rules/**/*.md"
      }
    ],
    // MCP: Officially supported but configuration path unclear (likely UI-based)
    // Agents: Custom agent feature promoted but configuration method unclear
    "import": [
      {
        "from": ".trae-cn/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".trae-cn/rules/**/*.md",
        "to": "rules/**/*.md"
      }
    ]
  },

  "warp": {
    "name": "Warp",
    "detection": [".warp", "WARP.md"],
    "export": [
      {
        "from": "AGENTS.md",
        "to": "WARP.md",
        "merge": "composite"
      }
    ],
    "import": [
      {
        "from": "WARP.md",
        "to": "AGENTS.md",
        "merge": "composite"
      }
    ]
  },

  "windsurf": {
    "name": "Windsurf",
    "detection": [".windsurf"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".windsurf/rules/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".windsurf/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".windsurf/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".windsurf/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "zencoder": {
    "name": "Zencoder",
    "detection": [".zencoder"],
    "export": [
      {
        "from": "skills/**/*",
        "to": ".zencoder/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".zencoder/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  }
}
