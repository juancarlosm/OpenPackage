{
  "$schema": "./schemas/platforms-v1.json",

  // Global flows that apply to all platforms
  "global": {
    "export": [
      {
        "from": "AGENTS.md",
        "to": "AGENTS.md",
        "when": { "exists": "AGENTS.md" },
        "merge": "composite"
      }
    ],
    "import": [
      {
        "from": "AGENTS.md",
        "to": "AGENTS.md",
        "merge": "composite"
      }
    ]
  },

  // Platform definitions for all supported AI coding platforms
  // Each platform defines export flows (package → workspace) and import flows (workspace → package)

  "antigravity": {
    "name": "Google Antigravity",
    "detection": [".agent"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".agent/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".agent/workflows/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".agent/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".agent/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".agent/workflows/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".agent/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "augment": {
    "name": "Augment Code",
    "detection": [".augment"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".augment/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".augment/commands/**/*.md"
      }
    ],
    "import": [
      {
        "from": ".augment/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".augment/commands/**/*.md",
        "to": "commands/**/*.md"
      }
    ]
  },

  "claude-plugin": {
    "name": "Claude Code Plugin",
    "detection": [".claude-plugin/plugin.json"],
    "export": [
      {
        "from": "openpackage.yml",
        "to": ".claude-plugin/plugin.json"
      },
      {
        "from": "rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": "mcp.jsonc",
        "to": ".mcp.json",
        "map": [
          // Claude plugin `.mcp.json` expects a bare server map:
          //   { "linear": { ... } }
          // Universal format is:
          //   { "mcpServers": { "linear": { ... } } }
          // Only transform keys under `mcpServers` (no-op if missing).
          { "$rename": { "mcpServers.*": "*" } },
          { "$unset": "mcpServers" }
        ]
      }
    ],
    "import": [
      {
        "from": ".claude-plugin/plugin.json",
        "to": "openpackage.yml"
      },
      {
        "from": "rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": "agents/**/*.md",
        // No mapping when target platform is Claude (already in Claude format)
        "when": {
          "$eq": ["$$platform", "claude"]
        }
      },
      {
        "from": "agents/**/*.md",
        "to": "agents/**/*.md",
        // Apply reverse transformations when target platform is NOT Claude
        "when": {
          "$ne": ["$$platform", "claude"]
        },
        "map": [
          // Reverse model transformation
          {
            "$pipeline": {
              "field": "model",
              "operations": [
                // Step 1: Convert version hyphens back to dots
                // claude-sonnet-4-20250514 → claude-sonnet-4.20250514
                { "$replace": { "pattern": "(-[0-9]+)-([0-9]+)", "with": "$1.$2", "flags": "g" } },
                
                // Step 2: Add anthropic/ prefix ONLY if:
                //   - It starts with "claude-" (Claude model without prefix)
                //   - NOT if it's "default"
                //   - NOT if it already has "anthropic/"
                { "$replace": { "pattern": "^(claude-.+)$", "with": "anthropic/$1" } }
              ]
            }
          },
          
          // Reverse tools transformation: "Bash, Read" → [bash, read]
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Step 1: Split "Read, Write, Bash" → ["Read", "Write", "Bash"]
                { "$reduce": { "type": "split", "separator": ", " } },
                // Step 2: Lowercase all (Read→read, Bash→bash, AskUserQuestion→askuserquestion)
                { "$map": { "each": "lowercase" } },
                // Step 3: Replace special cases AFTER lowercase
                { "$map": {
                    "replace": {
                      "askuserquestion": "question",
                      "notebookedit": "notebook",
                      "exitplanmode": "exitplan"
                    }
                }}
              ]
            }
          }
        ]
      },
      {
        "from": "skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".mcp.json",
        "to": "mcp.jsonc",
        "map": [
          // Claude plugin `.mcp.json` may be a bare server map:
          //   { "linear": { ... } }
          // Convert to universal format:
          //   { "mcpServers": { "linear": { ... } } }
          { "$rename": { "*": "mcpServers.*" } }
        ]
      }
    ]
  },

  "claude": {
    "name": "Claude Code",
    "detection": [".claude", "CLAUDE.md"],
    "aliases": ["claudecode"],
    "export": [
      {
        "from": "AGENTS.md",
        "to": "CLAUDE.md",
        "merge": "composite"
      },
      {
        "from": "rules/**/*.md",
        "to": ".claude/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".claude/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".claude/agents/**/*.md",
        // No mapping when source is Claude plugin (already in Claude format)
        "when": {
          "$eq": ["$$source", "claude-plugin"]
        }
      },
      {
        "from": "agents/**/*.md",
        "to": ".claude/agents/**/*.md",
        // Apply transformations when source is NOT Claude plugin
        "when": {
          "$ne": ["$$source", "claude-plugin"]
        },
        "map": [
          // 1. Inject filename as name (Claude requirement)
          { "$set": { "name": "$$filename" } },
          
          // 2. Transform model: "provider/model-id" → Claude short names
          {
            "$pipeline": {
              "field": "model",
              "operations": [
                // Step 1: For non-Anthropic providers (openai/, google/, etc.), set to "inherit"
                // But preserve Claude shorthand names (opus, sonnet, haiku) and full claude- model IDs
                { "$replace": { "pattern": "^(?!anthropic/|claude-|opus$|sonnet$|haiku$).*/.+$", "with": "inherit" } },
                // Step 2: Remove anthropic/ prefix
                { "$replace": { "pattern": "^anthropic/", "with": "" } },
                // Step 3: Convert version dots to hyphens: claude-sonnet-4.20250514 → claude-sonnet-4-20250514
                { "$replace": { "pattern": "(-[0-9]+)\\.([0-9]+)", "with": "$1-$2", "flags": "g" } }
              ]
            }
          },
          
          // 3. Transform tools: [read, write, bash] → "Read, Write, Bash"
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Step 1: Replace special cases BEFORE capitalization
                { "$map": { 
                    "replace": {
                      "question": "AskUserQuestion",
                      "notebook": "NotebookEdit", 
                      "exitplan": "ExitPlanMode"
                    }
                }},
                // Step 2: Capitalize everything (handles read→Read, bash→Bash, etc.)
                { "$map": { "each": "capitalize" } },
                // Step 3: Join with comma-space
                { "$reduce": { "type": "join", "separator": ", " } }
              ]
            }
          },
          
          // 4. Smart map permissions object → permissionMode string
          // Only transform if permissions field exists
          {
            "$switch": {
              "field": "permissions",
              "cases": [
                // Full automation: all allow
                { 
                  "pattern": { "edit": "allow", "bash": "allow", "webfetch": "allow" }, 
                  "value": "bypassPermissions" 
                },
                { 
                  "pattern": { "edit": "allow", "bash": "allow" }, 
                  "value": "bypassPermissions" 
                },
                
                // Auto-accept edits
                { 
                  "pattern": { "edit": "allow", "bash": "ask" }, 
                  "value": "acceptEdits" 
                },
                { 
                  "pattern": { "edit": "allow" }, 
                  "value": "acceptEdits" 
                },
                
                // Read-only mode
                { 
                  "pattern": { "edit": "deny", "bash": "deny" }, 
                  "value": "plan" 
                },
                
                // Deny unclear operations
                { 
                  "pattern": { "edit": "deny", "bash": "ask" }, 
                  "value": "dontAsk" 
                },
                { 
                  "pattern": { "edit": "deny", "bash": "allow" }, 
                  "value": "dontAsk" 
                },
                
                // Standard prompting
                { 
                  "pattern": { "edit": "ask", "bash": "ask" }, 
                  "value": "default" 
                },
                { 
                  "pattern": { "edit": "ask" }, 
                  "value": "default" 
                }
              ]
            }
          },
          { "$rename": { "permissions": "permissionMode" } }
        ]
      },
      {
        "from": "skills/**/*",
        "to": ".claude/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".mcp.json",
        "when": {
          "$ne": ["$$targetRoot", "~/"]
        },
        "merge": "deep"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".claude.json",
        "when": {
          "$eq": ["$$targetRoot", "~/"]
        },
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": "CLAUDE.md",
        "to": "AGENTS.md",
        "merge": "composite"
      },
      {
        "from": ".claude/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".claude/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".claude/agents/**/*.md",
        "to": "agents/**/*.md",
        "map": [
          // Reverse model transformation: Claude short names → "anthropic/model-id"
          {
            "$pipeline": {
              "field": "model",
              "operations": [
                // Convert version hyphens back to dots: claude-sonnet-4-20250514 → claude-sonnet-4.20250514
                { "$replace": { "pattern": "(-[0-9]+)-([0-9]+)", "with": "$1.$2", "flags": "g" } },
                
                // Add anthropic/ prefix if it's a Claude model (starts with "claude-")
                // Skip if it's "inherit" or already has "anthropic/"
                { "$replace": { "pattern": "^(claude-.+)$", "with": "anthropic/$1" } }
              ]
            }
          },
          
          // Reverse tools transformation: "Read, Write, Bash" → [read, write, bash]
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Step 1: Split "Read, Write, Bash" → ["Read", "Write", "Bash"]
                { "$reduce": { "type": "split", "separator": ", " } },
                // Step 2: Lowercase all (Read→read, Bash→bash, AskUserQuestion→askuserquestion)
                { "$map": { "each": "lowercase" } },
                // Step 3: Replace special cases AFTER lowercase
                { "$map": {
                    "replace": {
                      "askuserquestion": "question",
                      "notebookedit": "notebook",
                      "exitplanmode": "exitplan"
                    }
                }}
              ]
            }
          },
          
          // Transform permissionMode → permissions object (best effort)
          // Only transform if permissionMode field exists
          {
            "$switch": {
              "field": "permissionMode",
              "cases": [
                { "pattern": "bypassPermissions", "value": { "edit": "allow", "bash": "allow" } },
                { "pattern": "acceptEdits", "value": { "edit": "allow", "bash": "ask" } },
                { "pattern": "plan", "value": { "edit": "deny", "bash": "deny" } },
                { "pattern": "dontAsk", "value": { "edit": "deny", "bash": "ask" } },
                { "pattern": "default", "value": { "edit": "ask", "bash": "ask" } }
              ]
            }
          },
          { "$rename": { "permissionMode": "permissions" } }
        ]
      },
      {
        "from": ".claude/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".mcp.json",
        "to": "mcp.jsonc",
        "when": {
          "$ne": ["$$targetRoot", "~/"]
        }
      },
      {
        "from": ".claude.json",
        "to": "mcp.jsonc",
        "when": {
          "$eq": ["$$targetRoot", "~/"]
        }
      }
    ]
  },

  "codex": {
    "name": "Codex CLI",
    "detection": [".codex", "AGENTS.md"],
    "aliases": ["codexcli"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".codex/prompts/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".codex/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".codex/config.toml",
        "map": [
          // 1. Rename root key
          { "$rename": { "mcpServers": "mcp_servers" } },

          // 2. Extract bearer token from Authorization header
          {
            "$pipeline": {
              "field": "mcp_servers.*.headers.Authorization",
              "operations": [
                { "$extract": {
                    "pattern": "^Bearer \\$\\{env:([A-Z_][A-Z0-9_]*)\\}$",
                    "group": 1,
                    "default": "$SELF"
                }}
              ]
            }
          },
          { "$rename": { "mcp_servers.*.headers.Authorization": "mcp_servers.*.bearer_token_env_var" } },

          // 3. Partition headers into env and static
          {
            "$pipeline": {
              "field": "mcp_servers.*.headers",
              "operations": [
                { "$partition": {
                    "by": "value",
                    "patterns": {
                      "env_http_headers": "^\\$\\{env:.*\\}$",
                      "http_headers": ".*"
                    }
                }}
              ]
            }
          },

          // 4. Extract env var names from env_http_headers
          {
            "$pipeline": {
              "field": "mcp_servers.*.headers.env_http_headers",
              "operations": [
                { "$mapValues": {
                    "operations": [
                      { "$extract": {
                          "pattern": "^\\$\\{env:([A-Z_][A-Z0-9_]*)\\}$",
                          "group": 1
                      }}
                    ]
                }}
              ]
            }
          },

          // 5. Flatten to server level
          { "$rename": { "mcp_servers.*.headers.http_headers": "mcp_servers.*.http_headers" } },
          { "$rename": { "mcp_servers.*.headers.env_http_headers": "mcp_servers.*.env_http_headers" } },
          { "$unset": "mcp_servers.*.headers" },

          // 6. Rename timeout
          { "$rename": { "mcp_servers.*.timeout": "mcp_servers.*.startup_timeout_sec" } },

          // Post-process: Convert to TOML
          { "$pipe": ["json-to-toml"] }
        ],
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".codex/prompts/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".codex/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": ".codex/config.toml",
        "to": "mcp.jsonc",
        "map": [
          // Pre-process: Parse TOML
          { "$pipe": ["toml-to-json"] },

          // 1. Wrap env vars
          {
            "$pipeline": {
              "field": "mcp_servers.*.env_http_headers",
              "operations": [
                { "$mapValues": {
                    "operations": [
                      { "$replace": { "pattern": "^(.+)$", "with": "${env:$1}" } }
                    ]
                }}
              ]
            }
          },

          // 2. Merge headers
          {
            "$pipeline": {
              "field": "mcp_servers.*",
              "operations": [
                { "$mergeFields": {
                    "from": ["http_headers", "env_http_headers"],
                    "to": "headers"
                }}
              ]
            }
          },

          // 3. Reconstruct Authorization header
          {
            "$pipeline": {
              "field": "mcp_servers.*.bearer_token_env_var",
              "operations": [
                { "$replace": { "pattern": "^(.+)$", "with": "Bearer ${env:$1}" } }
              ]
            }
          },
          { "$rename": { "mcp_servers.*.bearer_token_env_var": "mcp_servers.*.headers.Authorization" } },

          // 4. Rename timeout
          { "$rename": { "mcp_servers.*.startup_timeout_sec": "mcp_servers.*.timeout" } },

          // 5. Rename top-level key
          { "$rename": { "mcp_servers": "mcpServers" } }
        ]
      }
    ]
  },

  "cursor": {
    "name": "Cursor",
    "detection": [".cursor", "AGENTS.md"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".cursor/rules/**/*.mdc"
      },
      {
        "from": "commands/**/*.md",
        "to": ".cursor/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".cursor/agents/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".cursor/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".cursor/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": [".cursor/rules/**/*.mdc", ".cursor/rules/**/*.md"],
        "to": "rules/**/*.md"
      },
      {
        "from": ".cursor/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".cursor/agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".cursor/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".cursor/mcp.json", ".cursor/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "factory": {
    "name": "Factory AI",
    "detection": [".factory", "AGENTS.md"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".factory/commands/**/*.md"
      },
      {
        "from": "agents/**/*.md",
        "to": ".factory/droids/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".factory/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".factory/settings/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".factory/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".factory/droids/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".factory/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".factory/settings/mcp.json", ".factory/settings/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "kilo": {
    "name": "Kilo Code",
    "detection": [".kilocode", "AGENTS.md"],
    "aliases": ["kilocode"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".kilocode/rules/**/*.md"
      },
      {
        "from": "commands/**/*.md",
        "to": ".kilocode/workflows/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".kilocode/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".kilocode/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".kilocode/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".kilocode/workflows/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".kilocode/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".kilocode/mcp.json", ".kilocode/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "kiro": {
    "name": "Kiro",
    "detection": [".kiro"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".kiro/steering/**/*.md"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".kiro/settings/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".kiro/steering/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": [".kiro/settings/mcp.json", ".kiro/settings/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "opencode": {
    "name": "OpenCode",
    "detection": [".opencode", "AGENTS.md"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/command/**/*.md" }
            ],
            "default": ".opencode/command/**/*.md"
          }
        }
      },
      {
        "from": "agents/**/*.md",
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/agent/**/*.md" }
            ],
            "default": ".opencode/agent/**/*.md"
          }
        },
        "map": [
          // 1. Transform tools: [read, write, bash] → { read: true, write: true, bash: true }
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                { "$arrayToObject": { "value": true } }
              ]
            }
          },
          
          // 2. Model field: pass through as-is (already in OpenCode format)
          // 3. Permissions: pass through as-is (already in OpenCode format)
          // 4. Claude-specific fields preserved (skills, hooks, disallowedTools) - ignored by OpenCode but kept for information preservation
        ]
      },
      {
        "from": "skills/**/*",
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/skill/**/*" }
            ],
            "default": ".opencode/skill/**/*"
          }
        }
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/opencode.json" }
            ],
            "default": ".opencode/opencode.json"
          }
        },
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/command/**/*.md" }
            ],
            "default": ".opencode/command/**/*.md"
          }
        },
        "to": "commands/**/*.md"
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/agent/**/*.md" }
            ],
            "default": ".opencode/agent/**/*.md"
          }
        },
        "to": "agents/**/*.md",
        "map": [
          // 1. Reverse tools transformation: { read: true, write: false, bash: true } → [read, bash]
          {
            "$pipeline": {
              "field": "tools",
              "operations": [
                // Filter to only enabled tools
                { "$filter": { "match": { "value": true } } },
                // Extract keys
                { "$objectToArray": { "extract": "keys" } }
              ]
            }
          }
          
          // 2. Model field: pass through as-is (already in universal format)
          // 3. Permissions: pass through as-is (already in universal format)
        ]
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/skill/**/*" }
            ],
            "default": ".opencode/skill/**/*"
          }
        },
        "to": "skills/**/*"
      },
      {
        "from": {
          "$switch": {
            "field": "$$targetRoot",
            "cases": [
              { "pattern": "~/", "value": ".config/opencode/opencode.json" }
            ],
            "default": ".opencode/opencode.json"
          }
        },
        "to": "mcp.jsonc"
      }
    ]
  },

  // Pi-Mono AI coding assistant framework
  "pimono": {
    "name": "Pi-Mono",
    "detection": [".pi"],
    "aliases": ["pi-mono", "pi"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".pi/agent/prompts/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".pi/agent/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".pi/agent/prompts/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".pi/agent/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  },

  "qwen": {
    "name": "Qwen Code",
    "detection": [".qwen", "QWEN.md"],
    "aliases": ["qwencode"],
    "export": [
      {
        "from": "AGENTS.md",
        "to": "QWEN.md",
        "merge": "composite"
      },
      {
        "from": "agents/**/*.md",
        "to": ".qwen/agents/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".qwen/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".qwen/settings.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": "QWEN.md",
        "to": "AGENTS.md",
        "merge": "composite"
      },
      {
        "from": ".qwen/agents/**/*.md",
        "to": "agents/**/*.md"
      },
      {
        "from": ".qwen/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".qwen/settings.json", ".qwen/settings.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "roo": {
    "name": "Roo Code",
    "detection": [".roo", "AGENTS.md"],
    "export": [
      {
        "from": "commands/**/*.md",
        "to": ".roo/commands/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".roo/skills/**/*"
      },
      {
        "from": ["mcp.jsonc", "mcp.json"],
        "to": ".roo/mcp.json",
        "merge": "deep"
      }
    ],
    "import": [
      {
        "from": ".roo/commands/**/*.md",
        "to": "commands/**/*.md"
      },
      {
        "from": ".roo/skills/**/*",
        "to": "skills/**/*"
      },
      {
        "from": [".roo/mcp.json", ".roo/mcp.jsonc"],
        "to": "mcp.jsonc"
      }
    ]
  },

  "warp": {
    "name": "Warp",
    "detection": [".warp", "WARP.md"],
    "export": [
      {
        "from": "AGENTS.md",
        "to": "WARP.md",
        "merge": "composite"
      }
    ],
    "import": [
      {
        "from": "WARP.md",
        "to": "AGENTS.md",
        "merge": "composite"
      }
    ]
  },

  "windsurf": {
    "name": "Windsurf",
    "detection": [".windsurf"],
    "export": [
      {
        "from": "rules/**/*.md",
        "to": ".windsurf/rules/**/*.md"
      },
      {
        "from": "skills/**/*",
        "to": ".windsurf/skills/**/*"
      }
    ],
    "import": [
      {
        "from": ".windsurf/rules/**/*.md",
        "to": "rules/**/*.md"
      },
      {
        "from": ".windsurf/skills/**/*",
        "to": "skills/**/*"
      }
    ]
  }
}
